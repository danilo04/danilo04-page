---
slug: reactive-android-kotlin-flows
title: Construyendo Apps Android Reactivas con Kotlin Flows
summary: Una inmersi칩n profunda en el uso de Kotlin Flows para construir aplicaciones Android reactivas y responsivas. Aprende a manejar flujos de datos as칤ncronos de manera efectiva.
category: mobile
coverImage: https://images.unsplash.com/photo-1607252650355-f7fd0460ccdb?w=1200&h=630&fit=crop
author: Danilo Dominguez
date: 2026-01-06
readTime: 12 min de lectura
tags:
  - Kotlin
  - Android
  - Flows
  - Coroutines
  - Reactive Programming
published: true
---

# Construyendo Apps Android Reactivas con Kotlin Flows

En el desarrollo moderno de Android, manejar flujos de datos as칤ncronos es crucial para construir aplicaciones responsivas. **Kotlin Flows** proporciona una soluci칩n poderosa basada en coroutines para programaci칩n reactiva que se integra perfectamente con el ciclo de vida de Android.

## 쯈u칠 son los Kotlin Flows?

Los Kotlin Flows son un tipo de **flujo as칤ncrono fr칤o** que emite valores secuencialmente y completa normalmente o con una excepci칩n. A diferencia de `LiveData`, los Flows est치n construidos sobre Kotlin Coroutines y ofrecen m치s flexibilidad y poder para manejar transformaciones de datos complejas.

```kotlin
// Un Flow simple que emite n칰meros
val numbersFlow: Flow<Int> = flow {
    for (i in 1..5) {
        delay(1000)
        emit(i)
    }
}
```

## Flow vs StateFlow vs SharedFlow

Entender las diferencias entre estos tres tipos es esencial:

### Flow (Flujo Fr칤o)
- Comienza a emitir solo cuando se recolecta
- Cada colector obtiene su propio flujo independiente
- Perfecto para operaciones 칰nicas como llamadas API

```kotlin
fun fetchUserData(): Flow<User> = flow {
    val user = api.getUser()
    emit(user)
}
```

### StateFlow (Flujo Caliente con Estado)
- Siempre tiene un valor actual
- Los nuevos colectores reciben inmediatamente el estado actual
- Ideal para gesti칩n de estado de UI

```kotlin
class UserViewModel : ViewModel() {
    private val _uiState = MutableStateFlow(UserUiState())
    val uiState: StateFlow<UserUiState> = _uiState.asStateFlow()
    
    fun updateName(name: String) {
        _uiState.update { it.copy(name = name) }
    }
}
```

### SharedFlow (Flujo Caliente sin Estado)
- Sin valor inicial
- Puede reproducir emisiones a nuevos colectores
- Excelente para eventos como navegaci칩n o mensajes de snackbar

```kotlin
class EventViewModel : ViewModel() {
    private val _events = MutableSharedFlow<UiEvent>()
    val events: SharedFlow<UiEvent> = _events.asSharedFlow()
    
    fun showMessage(message: String) {
        viewModelScope.launch {
            _events.emit(UiEvent.ShowSnackbar(message))
        }
    }
}
```

## Recolectando Flows en Android

El desaf칤o clave en Android es recolectar flows **de manera segura** con respecto al ciclo de vida. Aqu칤 est치n las mejores pr치cticas:

### Usando repeatOnLifecycle

```kotlin
class UserActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        lifecycleScope.launch {
            repeatOnLifecycle(Lifecycle.State.STARTED) {
                viewModel.uiState.collect { state ->
                    updateUi(state)
                }
            }
        }
    }
}
```

### Con Jetpack Compose

Compose hace que recolectar flows sea a칰n m치s f치cil con la extensi칩n `collectAsState`:

```kotlin
@Composable
fun UserScreen(viewModel: UserViewModel = viewModel()) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()
    
    Column {
        Text(text = "Hola, ${uiState.name}")
        // ... resto de la UI
    }
}
```

## Operadores de Flow para Transformaciones

Los Flows vienen con operadores poderosos para transformar datos:

```kotlin
repository.getUsersFlow()
    .map { users -> users.filter { it.isActive } }
    .distinctUntilChanged()
    .debounce(300)
    .catch { e -> emit(emptyList()) }
    .flowOn(Dispatchers.IO)
    .collect { activeUsers ->
        updateUserList(activeUsers)
    }
```

### Operadores Comunes

| Operador | Descripci칩n |
|----------|-------------|
| `map` | Transforma cada valor emitido |
| `filter` | Solo emite valores que coincidan con un predicado |
| `debounce` | Espera silencio antes de emitir |
| `distinctUntilChanged` | Omite duplicados consecutivos |
| `combine` | Combina m칰ltiples flows |
| `flatMapLatest` | Cancela el anterior cuando llega un nuevo valor |

## Ejemplo del Mundo Real: B칰squeda con Debounce

Aqu칤 hay un ejemplo pr치ctico de implementar una funci칩n de b칰squeda con debouncing:

```kotlin
class SearchViewModel(
    private val searchRepository: SearchRepository
) : ViewModel() {
    
    private val _searchQuery = MutableStateFlow("")
    
    val searchResults: StateFlow<SearchUiState> = _searchQuery
        .debounce(300) // Espera 300ms despu칠s de dejar de escribir
        .distinctUntilChanged() // Solo busca si la consulta cambi칩
        .flatMapLatest { query ->
            if (query.isBlank()) {
                flowOf(SearchUiState.Empty)
            } else {
                searchRepository.search(query)
                    .map { results -> SearchUiState.Success(results) }
                    .onStart { emit(SearchUiState.Loading) }
                    .catch { emit(SearchUiState.Error(it.message)) }
            }
        }
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = SearchUiState.Empty
        )
    
    fun onSearchQueryChanged(query: String) {
        _searchQuery.value = query
    }
}
```

## Manejo de Errores en Flows

El manejo apropiado de errores es crucial para apps en producci칩n:

```kotlin
flow {
    emit(api.fetchData())
}
.retry(3) { cause ->
    cause is IOException
}
.catch { exception ->
    // Manejar o transformar la excepci칩n
    emit(fallbackValue)
}
.collect { data ->
    processData(data)
}
```

## Probando Flows

Probar flows es sencillo con la librer칤a `turbine`:

```kotlin
@Test
fun `b칰squeda emite loading luego resultados`() = runTest {
    val viewModel = SearchViewModel(fakeRepository)
    
    viewModel.searchResults.test {
        assertEquals(SearchUiState.Empty, awaitItem())
        
        viewModel.onSearchQueryChanged("kotlin")
        
        assertEquals(SearchUiState.Loading, awaitItem())
        assertEquals(SearchUiState.Success(expectedResults), awaitItem())
        
        cancelAndIgnoreRemainingEvents()
    }
}
```

## Conclusi칩n

Kotlin Flows proporcionan una forma poderosa y flexible de manejar flujos de datos as칤ncronos en Android. Al entender las diferencias entre Flow, StateFlow y SharedFlow, y al usar los m칠todos de recolecci칩n apropiados con conciencia del ciclo de vida, puedes construir aplicaciones robustas y reactivas que manejan escenarios de datos complejos con facilidad.

### Puntos Clave

1. Usa **StateFlow** para estado de UI que necesita un valor actual
2. Usa **SharedFlow** para eventos 칰nicos
3. Siempre recolecta con **conciencia del ciclo de vida**
4. Aprovecha los **operadores** para transformaciones complejas
5. Usa `stateIn` para convertir flows fr칤os a StateFlows calientes

춰Feliz codificaci칩n! 游

